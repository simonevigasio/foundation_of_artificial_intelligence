# Enable the filesystem to access the parent directory.
import sys
sys.path.append('../')

# Import essential classes and functions required to work with the search problem.
from search_problem_init import *

# Function to check if the search is moving backward for 'k' iterations 
# and encountering the same node repeatedly, indicating a cycle.
def is_cycle(node, k=30):
    """Checks if the given node is part of a cycle of length 'k' or less."""

    # Recursive subfunction to check if the node's ancestor matches the initial node's state.
    # The function stops when 'k' iterations are reached or when the ancestor is None.
    def find_cycle(ancestor, k):
        return (ancestor is not None and k > 0 and 
                (ancestor.state == node.state or find_cycle(ancestor.parent, k - 1)))
    
    # Start the recursive check from the parent of the current node.
    return find_cycle(node.parent, k)

# Implement the depth-first search algorithm using a recursive approach.
def depth_first_search_recursive(problem, node=None):
    """Search deepest nodes in the search tree first."""
    
    # Initialize the node with the initial state of the problem if not provided.
    if node is None:
        node = Node(problem.initial)

    # Check if the current node's state is the goal state.
    if problem.is_goal(node.state):
        return node
    
    # Check for cycles to avoid revisiting nodes and entering infinite loops.
    elif is_cycle(node):
        return failure
    
    # If the current node is not the goal and no cycle is detected:
    else:

        # Iterate over all child nodes generated by expanding the current node.
        for child in node.expand(problem):

            # Recursively apply depth-first search to the child node.
            result = depth_first_search_recursive(problem, child)

            # If a solution is found, return the result.
            if result:
                return result
        
        # If no solution is found after exploring all children, return failure.
        return failure

# Implement the depth-first search algorithm using an iterative approach.
def depth_first_search_iterative(problem):
    """Searches the deepest nodes in the search tree first."""

    # Initialize the frontier using a Last-In-First-Out (LIFO) behavior, resembling a stack.
    frontier = LIFOQueue([Node(problem.initial)])

    # Initialize the result to the failure node, indicating no solution found yet.
    result = failure
    
    # Continue the search loop until the frontier is empty, indicating all nodes have been explored.
    while frontier:

        # Remove and return the last element added to the frontier (stack behavior).
        node = frontier.pop()

        # Check if the current node's state is the goal state.
        if problem.is_goal(node.state):
            return node  # Return the goal node if found.
        
        # Check if the current node has a cycle to avoid revisiting nodes.
        elif not is_cycle(node):

            # Expand the current node to generate its child nodes.
            for child in node.expand(problem):

                # Add each child node to the frontier for further exploration.
                frontier.append(child)
    
    # Return the result, which is the failure node if no solution was found.
    return result