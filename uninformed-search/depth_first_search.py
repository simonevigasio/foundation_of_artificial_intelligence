# Enable the filesystem to access the parent directory.
import sys
sys.path.append('../')

# Import essential classes and functions required to work with the search problem.
from search_problem_init import *

# Function to check if the search is moving backward for 'k' iterations 
# and encountering the same node repeatedly, indicating a cycle.
def is_cycle(node, k=30):
    """Checks if the given node is part of a cycle of length 'k' or less."""

    # Recursive subfunction to check if the node's ancestor matches the initial node's state.
    # The function stops when 'k' iterations are reached or when the ancestor is None.
    def find_cycle(ancestor, k):
        return (ancestor is not None and k > 0 and 
                (ancestor.state == node.state or find_cycle(ancestor.parent, k - 1)))
    
    # Start the recursive check from the parent of the current node.
    return find_cycle(node.parent, k)

# Implement the depth-first search algorithm using a recursive approach.
def depth_first_search_recursive(problem, node=None):
    
    # Initialize the node with the initial state of the problem if not provided.
    if node is None:
        node = Node(problem.initial)

    # Check if the current node's state is the goal state.
    if problem.is_goal(node.state):
        return node
    
    # Check for cycles to avoid revisiting nodes and entering infinite loops.
    elif is_cycle(node):
        return failure
    
    # If the current node is not the goal and no cycle is detected:
    else:

        # Iterate over all child nodes generated by expanding the current node.
        for child in node.expand(problem):

            # Recursively apply depth-first search to the child node.
            result = depth_first_search_recursive(problem, child)

            # If a solution is found, return the result.
            if result:
                return result
        
        # If no solution is found after exploring all children, return failure.
        return failure